// array slices (n) - P. Ahrenkiel

#include <cstdlib>
#include <math.h>
#include <iostream>

namespace arr {
//
template <class data_type>
arr2slice<data_type>::arr2slice(arr2<data_type>* a,
const std::size_t iDim,
const std::size_t iIndex)
{
	m_a = a;
	if (iDim < 2)
	m_iDim = iDim;
	else
	m_iDim = 1;
	if (iIndex < m_a->size(m_iDim))
	m_iIndex = iIndex;
	else
	m_iIndex = m_a->size(m_iDim) - 1;
}

//
template <class data_type>
arr2slice<data_type>::arr2slice(const arr2slice<data_type>& A)
: arr2slice(A.data(), A.dim(), A.index())
{
}

//
template <class data_type>
arr2slice<data_type>::~arr2slice()
{
	// std::cout<<"-----------\n";
	// std::cout<<"destructing slice pointing to: "<<std::hex<<a->source();
	// std::cout<<", dim: "<<iDim;
	// std::cout<<", index: "<<iIndex<<"\n";
}

//
template <class data_type>
void arr2slice<data_type>::operator=(const arr2slice<data_type> A)
{
	if (m_iDim != A.dim())
	return;
	std::size_t nA = size(), nB = size();
	std::size_t n = nA;
	if (n > nB)
	n = nB;
	for (std::size_t i = 0; i < n; ++i)
	at(i) = A(i);
}

//
template <class data_type>
void arr2slice<data_type>::operator=(const arr1<data_type>& A)
{
	if (size() != A.size())
	return;
	std::size_t n = size();
	for (std::size_t i = 0; i < n; i++)
	at(i) = A(i);
}

//
template <class data_type>
std::size_t arr2slice<data_type>::size() const
{
	return m_a->size(1 - m_iDim);
}

//
template <class data_type>
data_type arr2slice<data_type>::at(const std::size_t i) const
{
	data_type x;
	if (m_iDim == 0)
	x = m_a->at(m_iIndex, i);
	else
	x = m_a->at(i, m_iIndex);
	return x;
}

//
template <class data_type>
data_type& arr2slice<data_type>::at(const std::size_t i)
{
	if (m_iDim == 0) {
		return m_a->at(m_iIndex, i);
	}
	return m_a->at(i, m_iIndex);
}

//
template <class data_type>
arr2<data_type>::arr2(const arr2slice<data_type>& A)
: arr2((A.dim() == 0) ? 1 : A.size(), (A.dim() == 1) ? 1 : A.size())
{
	std::size_t n = A.size();
	std::size_t i;
	switch (A.dim()) {
		case 0:
		for (i = 0; i < n; ++i)
		at(0, i) = A(i);
		break;
		
		case 1:
		for (i = 0; i < n; ++i)
		at(i, 0) = A(i);
		break;
	}
}

//
template <class data_type>
arr1<data_type>::arr1(const arr2slice<data_type>& A) : arr1<data_type>(A.size())
{
	for (std::size_t i = 0; i < size(); i++)
	at(i) = A(i);
}

//
template <class data_type>
arr1<data_type>& arr1<data_type>::operator=(const arr2slice<data_type>& A)
{
	return *this = arr1<data_type>(A);
}

// friend
template <class data_type>
std::ostream& operator<<(std::ostream& os, const arr2slice<data_type>& A)
{
	os << (arr2<data_type>)(A);
	return os;
}
} // namespace arr
