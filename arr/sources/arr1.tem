// arrays (n) - P. Ahrenkiel

#include <cstdlib>
#include <iostream>
#include <math.h>

namespace arr {
//
template <class data_type>
arr1<data_type>::arr1(const size_t n, const data_type* a) : m_n(n)
{
    m_a = std::unique_ptr<data_type[]>(new data_type[m_n]);
    if ((m_a != nullptr) && (a != nullptr))
        for (std::size_t i = 0; i < size(); i++)
            m_a[i] = a[i];
}

//
template <class data_type>
arr1<data_type>::arr1(const arr1<data_type>& A) : arr1(A.size())
{
    for (std::size_t i = 0; i < m_n; i++)
        m_a[i] = A(i);
}

//
template <class data_type>
arr1<data_type>& arr1<data_type>::operator=(const arr1<data_type>& A)
{
    delete[] m_a.release();
    m_a = std::unique_ptr<data_type[]>(new data_type[A.m_n]);
    if (m_a != nullptr) {
        m_n = A.m_n;
        for (std::size_t i = 0; i < A.m_n; i++)
            m_a[i] = A(i);
    }
    return *this;
}

//
template <class data_type>
arr1<data_type> arr1<data_type>::reverse()
{
    arr1<data_type> rA(size());
    for (std::size_t i = 0; i < m_n; i++)
        rA.m_a[m_n - i - 1] = m_a[i];
    return rA;
}

//
template <class data_type>
void arr1<data_type>::clear()
{
    delete [] m_a.release();
    m_a = nullptr;
    m_n = 0;
}

//
template <class data_type>
void arr1<data_type>::resize(const std::size_t n)
{
    arr1<data_type> b(*this);
    delete[] m_a.release();
    m_a = std::unique_ptr<data_type[]>(new data_type[n]);
    if (m_a != nullptr) {
        m_n = n;
        for (std::size_t i = 0; i < b.size(); i++)
            if (i < size())
                m_a[i] = b.m_a[i];
    }
}

//
template <class data_type>
void arr1<data_type>::append(const data_type ai)
{
    resize(m_n + 1);
    m_a[m_n - 1] = ai;
}

//
template <class data_type>
arr1<data_type>::~arr1()
{
    delete [] m_a.release();
    m_a = nullptr;
    m_n = 0;
}

//
template <class data_type>
bool arr1<data_type>::operator==(const arr1<data_type>& A) const
{
    bool res = true;
    if (A.size() != m_n) {
        return false;
    }
    for (std::size_t i = 0; i < m_n; i++)
        res = res & (m_a[i] == A(i));
    return res;
}

//
template <class data_type>
arr1<data_type> arr1<data_type>::operator=(const data_type& x)
{
    for (std::size_t i = 0; i < size(); i++)
        at(i) = x;
    return *this;
}

//
template <class data_type>
bool arr1<data_type>::operator!=(const arr1& A) const
{
    return !((*this) == A);
}

//
template <class data_type>
data_type& arr1<data_type>::at(const std::size_t i)
{
    if (i >= size())
        err = 1;
    return m_a[i];
}

//
template <class data_type>
data_type const& arr1<data_type>::at(const std::size_t i) const
{
    if (i >= size())
        err = 1;
    return m_a[i];
}

//
template <class data_type>
void arr1<data_type>::copy(data_type* a) const
{
    for (std::size_t i = 0; i < m_n; ++i)
        a[i] = m_a[i];
}

//
template <class data_type>
arr1<std::size_t> arr1<data_type>::iindex() const
{
    arr1<data_type> res(size());
    for (std::size_t i = 0; i < m_n; i++)
        res(i) = i;
    return res;
}

//
template <class data_type>
arr1<data_type> arr1<data_type>::operator()(const arr1<std::size_t> A)
{
    std::size_t m = A.size();
    arr1<data_type> res(m);
    for (std::size_t i = 0; i < m; i++)
        res(i) = at(A(i));
}

//
template <class data_type>
std::vector<data_type> arr1<data_type>::vect()
{
    std::vector<data_type> v(m_n);
    for (std::size_t i = 0; i < m_n; i++) {
        data_type x = at(i);
        v.at(i) = x;
    }
    return v;
}

//
template <class data_type>
std::ostream& operator<<(std::ostream& os, const arr1<data_type>& A)
{
    os << "(";
    for (size_t i = 0; i < A.size(); i++) {
        if (i > 0)
            os << "\t";
        os << A(i);
    }
    os << ")";
    return os;
}
} // namespace arr
