// arrays (m x n) - P. Ahrenkiel

#include <cstdlib>
#include <math.h>
#include <iostream>

#include "arr.hpp"

namespace arr {
//
template <class data_type>
arr2<data_type>::arr2(const std::size_t nRows, std::size_t nCols, const data_type* a)
    : m_nRows(nRows), m_nCols(nCols)
{
    m_a = std::unique_ptr<data_type[]>(new data_type[size()]);
    if ((m_a != nullptr) && (a != nullptr)) {
        for (std::size_t i = 0; i < m_nRows; i++)
            for (std::size_t j = 0; j < m_nCols; j++)
                m_a[i * m_nCols + j] = a[i * m_nCols + j];
    }
}

//
template <class data_type>
arr2<data_type>::arr2(const arr1<data_type>& A) : arr2(A.size(), 1)
{
    for (std::size_t i = 0; i < m_nRows; i++)
        m_a[i] = A(i);
}

// copy constructor
template <class data_type>
arr2<data_type>::arr2(const arr2<data_type>& A) : arr2(A.size(0), A.size(1))
{
    for (std::size_t i = 0; i < m_nRows; i++)
        for (std::size_t j = 0; j < m_nCols; j++)
            m_a[i * m_nCols + j] = A(i, j);
}

template <class data_type>
arr2<data_type>::arr2(std::initializer_list<std::initializer_list<data_type>> A)
{
	m_nRows = m_nCols = 0;
	bool first = true;
	for(auto &aRow:A)
	{
		if (first)
	 		m_nCols = aRow.size();
		if(aRow.size() < m_nCols)
			m_nCols = aRow.size();
		first = false;
		++m_nRows;
	}
	m_a = std::unique_ptr<data_type[]>(new data_type[size()]);
	if (m_a != nullptr) {
		std::size_t i = 0;
		for(auto &aRow:A)
		{
			std::size_t j = 0;
			for(auto &a:aRow)
			{
				if (j < m_nCols)
					m_a[i * m_nCols + j] = a;
				++j;
			}
			++i;
		}
	}
}

//
template <class data_type>
arr2<data_type>::~arr2()
{
    delete[] m_a.release();
    m_a = nullptr;
    m_nRows = m_nCols = 0;
}

//
template <class data_type>
arr2<data_type>& arr2<data_type>::operator=(const arr2<data_type>& A)
{
    if (this == &A)
        return *this;
    delete[] m_a.release();
    m_nRows = A.m_nRows;
    m_nCols = A.m_nCols;
    m_a = std::unique_ptr<data_type[]>(new data_type[size()]);
    if (m_a != nullptr)
        for (std::size_t i = 0; i < A.m_nRows; i++)
            for (std::size_t j = 0; j < A.m_nCols; j++)
                at(i, j) = A(i, j);

    return *this;
}

//
template <class data_type>
arr2<data_type>& arr2<data_type>::operator=(const data_type& x)
{
    for (std::size_t i = 0; i < m_nRows; i++)
        for (std::size_t j = 0; j < m_nCols; j++)
            at(i, j) = x;

    return *this;
}

//
template <class data_type>
std::size_t arr2<data_type>::size(const std::size_t d) const
{
    switch (d) {
    case 0:
        return m_nRows;
    case 1:
        return m_nCols;
    default:
        return 0;
    }
}

//
template <class data_type>
void arr2<data_type>::resize(const size_t nRows, const size_t nCols)
{
    arr2<data_type> b(*this);
    delete[] m_a;
    m_a = new data_type[nRows * nCols];
    if (m_a != nullptr) {
        m_nRows = nRows;
        m_nCols = nCols;
        for (std::size_t i = 0; i < b.m_nRows; i++)
            for (std::size_t j = 0; j < b.m_nCols; j++)
                if ((i < m_nRows) && (j < m_nCols))
                    at(i, j) = b(i, j);
    }
}

//
template <class data_type>
bool arr2<data_type>::operator==(const arr2<data_type>& A) const
{
    bool res = (m_nRows == A.m_nRows) && (m_nCols == A.m_nCols);
    if (res) {
        for (std::size_t i = 0; i < m_nRows; i++)
            for (std::size_t j = 0; j < m_nCols; j++)
                res = res & (at(i, j) == A(i, j));
    }
    return res;
}

//
template <class data_type>
bool arr2<data_type>::operator!=(const arr2<data_type>& A) const
{
    return !((*this) == A);
}

//
template <class data_type>
arr2<data_type> arr2<data_type>::T() const
{
    arr2<data_type> res(m_nCols, m_nRows);
    for (std::size_t i = 0; i < m_nRows; i++)
        for (std::size_t j = 0; j < m_nCols; j++)
            res(j, i) = at(i, j);
    return res;
}

//
template <class data_type>
data_type& arr2<data_type>::at(const std::size_t i, const std::size_t j)
{
    if (!((i < m_nRows) && (j < m_nCols)))
        err = 1;
    return m_a[i * m_nCols + j];
}

//
template <class data_type>
data_type const& arr2<data_type>::at(const std::size_t i, const std::size_t j) const
{
    if (!((i < m_nRows) && (j < m_nCols)))
        err = 1;
    return m_a[i * m_nCols + j];
}

//
template <class data_type>
arr1<data_type> arr2<data_type>::operator()(const std::size_t j) const
{
    std::size_t nRows = m_nRows;
    arr1<data_type> res(nRows);
    if (j > m_nCols) {
        err = -1;
        return res;
    }
    for (std::size_t i = 0; i < nRows; i++)
        res(i) = at(i, j);
    return res;
}

//
template <class data_type>
arr2<data_type>::arr2(const arr2sub<data_type>& A) : arr2<data_type>(A.size(0), A.size(1))
{
    for (std::size_t i = 0; i < m_nRows; i++)
        for (std::size_t j = 0; j < m_nCols; j++)
            at(i, j) = A(i, j);
}

//
template <class data_type>
arr2sub<data_type> arr2<data_type>::sub(const std::size_t iRow,
                                        const std::size_t iCol,
                                        const std::size_t nRows,
                                        const std::size_t nCols)
{
    return arr2sub<data_type>(this, iRow, iCol, nRows, nCols);
}

//
template <class data_type>
arr2sub<data_type> arr2<data_type>::operator()(const std::size_t iRow,
                                               const std::size_t iCol,
                                               const std::size_t nRows,
                                               const std::size_t nCols)
{
    return sub(iRow, iCol, nRows, nCols);
}

//
template <class data_type>
arr2slice<data_type> arr2<data_type>::slice(const std::size_t iDim, const std::size_t iIndex)
{
    std::size_t nSize = size(iDim);
    if (iDim == 0) {
        arr2slice<data_type> res(this, iIndex, nSize);
        return res;
    }
    arr2slice<data_type> res(this, nSize, iIndex);
    return res;
}

//
template <class data_type>
arr2slice<data_type> arr2<data_type>::row(const std::size_t iRow)
{
    return slice(0, iRow);
}

//
template <class data_type>
arr2slice<data_type> arr2<data_type>::col(const std::size_t iCol)
{
    return slice(1, iCol);
}

//
template <class data_type>
arr2<std::size_t> arr2<data_type>::icol() const
{
    arr2<std::size_t> res(m_nRows, m_nCols);
    for (std::size_t i = 0; i < m_nRows; i++)
        for (std::size_t j = 0; j < m_nCols; j++)
            res(i, j) = j;
    return res;
}

//
template <class data_type>
arr2<std::size_t> arr2<data_type>::irow() const
{
    arr2<std::size_t> res(m_nRows, m_nCols);
    for (std::size_t i = 0; i < m_nRows; i++)
        for (std::size_t j = 0; j < m_nCols; j++)
            res(i, j) = i;
    return res;
}

//
template <class data_type>
arr2<data_type> arr2<data_type>::operator()(const arr2<std::size_t> A, const arr2<std::size_t> B)
{
    if (m_nRows > B.m_nRows)
        m_nRows = B.m_nRows;
    if (m_nCols > B.m_nCols)
        m_nCols = B.m_nCols;
    arr2<data_type> res(m_nRows, m_nCols);
    for (std::size_t i = 0; i < m_nRows; i++)
        for (std::size_t j = 0; j < m_nCols; j++)
            res(i, j) = at(A(i, j), B(i, j));
}

//
template <class data_type>
arr2<data_type> arr2<data_type>::operator()(const arr2<std::size_t> A, const std::size_t Bi)
{
    arr2<data_type> res(m_nRows, m_nCols);
    for (std::size_t i = 0; i < m_nRows; i++)
        for (std::size_t j = 0; j < m_nCols; j++)
            res(i, j) = at(A(i, j), Bi);
}

//
template <class data_type>
arr2<data_type> arr2<data_type>::operator()(const std::size_t Ai, const arr2<std::size_t> B)
{
    arr2<data_type> res(m_nRows, m_nCols);
    for (std::size_t i = 0; i < m_nRows; i++)
        for (std::size_t j = 0; j < m_nCols; j++)
            res(i, j) = at(Ai, B(i, j));
}

//
template <class data_type>
bool arr2<data_type>::swapRows(const std::size_t iRow1, const std::size_t iRow2)
{
    if (!((iRow1 < m_nRows) && (iRow2 < m_nRows)))
        return false;
    for (std::size_t k = 0; k < m_nCols; k++) {
        data_type x = at(iRow1, k);
        at(iRow1, k) = at(iRow2, k);
        at(iRow2, k) = x;
    }
    return true;
}

//
template <class data_type>
bool arr2<data_type>::swapCols(const std::size_t iCol1, const std::size_t iCol2)
{
    if (!((iCol1 < m_nCols) && (iCol2 < m_nCols)))
        return false;
    for (std::size_t k = 0; k < m_nRows; k++) {
        data_type x = at(k, iCol1);
        at(k, iCol1) = at(k, iCol2);
        at(k, iCol2) = x;
    }
    return true;
}

//
template <class data_type>
std::vector<data_type> arr2<data_type>::vect()
{
    std::vector<data_type> v(size());
    for (std::size_t i = 0; i < m_nRows; i++)
        for (std::size_t j = 0; j < m_nCols; j++)
            v.at(i * m_nRows + j) = at(i, j);
    return v;
}

//
template <class data_type>
std::ostream& operator<<(std::ostream& os, const arr2<data_type>& A)
{
    for (size_t i = 0; i < A.size(0); i++) {
        for (size_t j = 0; j < A.size(1); j++) {
            if (j > 0)
                os << "\t";
            os << A(i, j);
        }
        os << std::endl;
    }
    return os;
}

//
template <class data_type>
arr2<data_type> arr2<data_type>::minor(const std::size_t m, const std::size_t n) const
{
    arr2<data_type> res(m_nRows - 1, m_nCols - 1);
    size_t ip = 0;
    for (size_t i = 0; i < m_nRows; i++)
        if (i != m) {
            size_t jp = 0;
            for (size_t j = 0; j < m_nCols; j++)
                if (j != n) {
                    res(ip, jp) = at(i, j);
                    jp++;
                }
            ip++;
        }
    return res;
}

} // namespace arr
